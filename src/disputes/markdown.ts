/**
 * Dispute markdown log generation
 *
 * Creates and updates a human-readable dispute.md file in the project root.
 * This file provides a quick overview of all disputes for human review.
 */

import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';
import type Database from 'better-sqlite3';
import {
  listDisputesWithTasks,
  calculateDaysOpen,
  type DisputeWithTask,
} from './queries.js';
import type {
  Dispute,
  DisputeType,
  DisputeStatus,
  ResolutionDecision,
} from './types.js';
import { DISPUTE_REASON_DESCRIPTIONS, isDisputeReason } from './types.js';

// ============ Configuration ============

const DISPUTE_FILE_NAME = 'dispute.md';

// ============ Markdown Generation ============

/**
 * Generate markdown content for all disputes
 */
export function generateDisputeMarkdown(db: Database.Database): string {
  const openDisputes = listDisputesWithTasks(db, { status: 'open' });
  const resolvedDisputes = listDisputesWithTasks(db, { status: 'resolved' });

  const lines: string[] = [];

  // Header
  lines.push('# Disputes');
  lines.push('');
  lines.push('> This file is auto-generated by Steroids CLI.');
  lines.push('> It provides a human-readable view of coder/reviewer disagreements.');
  lines.push('');

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push(`- **Open disputes:** ${openDisputes.length}`);
  lines.push(`- **Resolved disputes:** ${resolvedDisputes.length}`);
  lines.push(`- **Total disputes:** ${openDisputes.length + resolvedDisputes.length}`);
  lines.push('');

  // Open Disputes
  if (openDisputes.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Active Disputes');
    lines.push('');

    for (const dispute of openDisputes) {
      lines.push(generateDisputeSection(dispute));
      lines.push('');
    }
  }

  // Resolved Disputes
  if (resolvedDisputes.length > 0) {
    lines.push('---');
    lines.push('');
    lines.push('## Resolved Disputes');
    lines.push('');

    for (const dispute of resolvedDisputes) {
      lines.push(generateDisputeSection(dispute));
      lines.push('');
    }
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(`*Last updated: ${new Date().toISOString()}*`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate markdown section for a single dispute
 */
function generateDisputeSection(dispute: DisputeWithTask): string {
  const lines: string[] = [];
  const shortId = dispute.id.substring(0, 8);
  const taskShortId = dispute.task_id.substring(0, 8);
  const statusBadge = getStatusBadge(dispute.status, dispute.resolution);
  const typeBadge = getTypeBadge(dispute.type);

  // Header with badges
  lines.push(`### Dispute: ${shortId} ${statusBadge}`);
  lines.push('');

  // Metadata table
  lines.push(`| Field | Value |`);
  lines.push(`|-------|-------|`);
  lines.push(`| **Task** | ${dispute.task_title} (\`${taskShortId}\`) |`);
  lines.push(`| **Type** | ${typeBadge} ${dispute.type} |`);
  lines.push(`| **Reason** | ${formatReason(dispute.reason)} |`);
  lines.push(`| **Created** | ${formatDate(dispute.created_at)} (${calculateDaysOpen(dispute.created_at)} days ago) |`);
  lines.push(`| **Created By** | ${dispute.created_by} |`);
  lines.push('');

  // Coder Position
  if (dispute.coder_position) {
    lines.push('#### Coder Position');
    lines.push('');
    lines.push(dispute.coder_position);
    lines.push('');
  }

  // Reviewer Position
  if (dispute.reviewer_position) {
    lines.push('#### Reviewer Position');
    lines.push('');
    lines.push(dispute.reviewer_position);
    lines.push('');
  }

  // Resolution (if resolved)
  if (dispute.status === 'resolved' && dispute.resolution) {
    lines.push('#### Resolution');
    lines.push('');
    lines.push(`**Decision:** ${formatResolution(dispute.resolution)}`);
    if (dispute.resolved_by) {
      lines.push(`**Resolved By:** ${dispute.resolved_by}`);
    }
    if (dispute.resolved_at) {
      lines.push(`**Resolved At:** ${formatDate(dispute.resolved_at)}`);
    }
    if (dispute.resolution_notes) {
      lines.push('');
      lines.push(`**Notes:** ${dispute.resolution_notes}`);
    }
    lines.push('');
  } else {
    // Status for open disputes
    lines.push('#### Status');
    lines.push('');
    lines.push('**AWAITING HUMAN DECISION**');
    lines.push('');
    lines.push(`Run \`steroids dispute resolve ${shortId} --decision <coder|reviewer>\` to resolve.`);
    lines.push('');
  }

  return lines.join('\n');
}

// ============ Formatting Helpers ============

/**
 * Get status badge emoji
 */
function getStatusBadge(status: DisputeStatus, resolution: ResolutionDecision | null): string {
  if (status === 'open') {
    return '[OPEN]';
  }
  if (resolution === 'coder') {
    return '[RESOLVED: CODER]';
  }
  if (resolution === 'reviewer') {
    return '[RESOLVED: REVIEWER]';
  }
  if (resolution === 'custom') {
    return '[RESOLVED: CUSTOM]';
  }
  return '[RESOLVED]';
}

/**
 * Get type badge emoji
 */
function getTypeBadge(type: DisputeType): string {
  switch (type) {
    case 'major':
      return '!!';
    case 'minor':
      return '~';
    case 'coder':
      return 'C';
    case 'reviewer':
      return 'R';
    case 'system':
      return 'S';
  }
}

/**
 * Format reason with description if standard
 */
function formatReason(reason: string): string {
  if (isDisputeReason(reason)) {
    return `${reason} - ${DISPUTE_REASON_DESCRIPTIONS[reason]}`;
  }
  return reason;
}

/**
 * Format resolution decision
 */
function formatResolution(decision: ResolutionDecision): string {
  switch (decision) {
    case 'coder':
      return "Coder's implementation accepted";
    case 'reviewer':
      return 'Reviewer position accepted, coder must fix';
    case 'custom':
      return 'Custom solution required';
  }
}

/**
 * Format date for display
 */
function formatDate(isoDate: string): string {
  const date = new Date(isoDate);
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });
}

// ============ File Operations ============

/**
 * Write dispute.md file to project root
 */
export function writeDisputeFile(
  db: Database.Database,
  projectPath?: string
): { path: string; created: boolean } {
  const basePath = projectPath ?? process.cwd();
  const filePath = join(basePath, DISPUTE_FILE_NAME);
  const existed = existsSync(filePath);

  const content = generateDisputeMarkdown(db);
  writeFileSync(filePath, content, 'utf-8');

  return {
    path: filePath,
    created: !existed,
  };
}

/**
 * Read current dispute.md content
 */
export function readDisputeFile(projectPath?: string): string | null {
  const basePath = projectPath ?? process.cwd();
  const filePath = join(basePath, DISPUTE_FILE_NAME);

  if (!existsSync(filePath)) {
    return null;
  }

  return readFileSync(filePath, 'utf-8');
}

/**
 * Check if dispute.md exists
 */
export function disputeFileExists(projectPath?: string): boolean {
  const basePath = projectPath ?? process.cwd();
  const filePath = join(basePath, DISPUTE_FILE_NAME);
  return existsSync(filePath);
}

/**
 * Get dispute.md file path
 */
export function getDisputeFilePath(projectPath?: string): string {
  const basePath = projectPath ?? process.cwd();
  return join(basePath, DISPUTE_FILE_NAME);
}

// ============ Update Operations ============

/**
 * Update dispute.md after a dispute is created or resolved
 * Called automatically by create/resolve operations
 */
export function updateDisputeFile(
  db: Database.Database,
  projectPath?: string
): void {
  writeDisputeFile(db, projectPath);
}

/**
 * Generate markdown for a single dispute (for display in CLI)
 */
export function generateSingleDisputeMarkdown(dispute: DisputeWithTask): string {
  return generateDisputeSection(dispute);
}
